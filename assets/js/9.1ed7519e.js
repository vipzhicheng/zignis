(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{207:function(s,a,t){"use strict";t.r(a);var e=t(0),n=Object(e.a)({},(function(){var s=this,a=s.$createElement,t=s._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[t("h1",{attrs:{id:"核心命令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#核心命令"}},[s._v("#")]),s._v(" 核心命令")]),s._v(" "),t("h2",{attrs:{id:"zignis-application"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zignis-application"}},[s._v("#")]),s._v(" "),t("code",[s._v("zignis application")])]),s._v(" "),t("blockquote",[t("p",[s._v("alias: "),t("code",[s._v("app")])])]),s._v(" "),t("p",[s._v("默认这个命令没有任何功能，存在的意思是跟业务项目建立一个约定，建议业务项目添加的命令都写成这个命令的子命令。而业务项目之所以能为这个命令添加子命令是利用了 "),t("code",[s._v("Zignis")]),s._v(" 的命令扩展机制。")]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("zignis "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("make")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("command")]),s._v(" application/test --extend"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("zignis\n")])])]),t("p",[s._v("这样就可以为项目添加一个 test 命令，而这个命令在执行的时候需要使用 "),t("code",[s._v("zignis application test")]),s._v(" 的方式来调用。")]),s._v(" "),t("p",[s._v("通过 "),t("code",[s._v("zignis application help")]),s._v(" 可以看到当前业务项目定义的所有顶级子命令，因为如果项目实现的命令过多，层次也多的话，一般我们很难记住所有命令和参数，所以帮助命令是我们经常要执行的。")]),s._v(" "),t("h2",{attrs:{id:"zignis-hook"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zignis-hook"}},[s._v("#")]),s._v(" "),t("code",[s._v("zignis hook")])]),s._v(" "),t("p",[s._v("这个命令的输出显示了当前环境下可用的所有的钩子，所有实现这些钩子的逻辑都可以被执行。在输出当中能够看到钩子的名称，描述，以及钩子在哪个模块声明的：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("╔══════════════════════╤═════════════════════╤════════════════════════════════════════════════════╗\n║ Hook                 │ Package             │ Description                                        ║\n╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢\n║ hook_beforeCommand   │ zignis              │ Hook triggered before command execution.           ║\n╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢\n║ hook_afterCommand    │ zignis              │ Hook triggered after command execution.            ║\n╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢\n║ hook_components      │ zignis              │ Hook triggered when needing to fetch components    ║\n╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢\n║ hook_hook            │ zignis              │ Hook triggered in hook command.                    ║\n╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢\n║ hook_repl            │ zignis              │ Hook triggered in repl command.                    ║\n╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢\n║ hook_status          │ zignis              │ Hook triggered in status command.                  ║\n╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢\n║ hook_new_repo        │ zignis              │ Hook triggered in new command.                     ║\n╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢\n║ hook_zhike_cron      │ zignis-plugin-zhike │ Hook triggered in zignis zhike cron command        ║\n╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢\n║ hook_zhike_component │ zignis-plugin-zhike │ Hook triggered when zhike hook_components invoked  ║\n╟──────────────────────┼─────────────────────┼────────────────────────────────────────────────────╢\n║ hook_zhike_repl      │ zignis-plugin-zhike │ Hook triggered when zhike hook_repl invoked        ║\n╚══════════════════════╧═════════════════════╧════════════════════════════════════════════════════╝\n")])])]),t("p",[s._v("这里可以看到有一个特殊的钩子是 "),t("code",[s._v("hook_hook")]),s._v(" 实现这个钩子就可以声明钩子，任何插件都可以声明自己的钩子，让其他命令来调用，从而影响自身的行为，一般业务项目是不需要声明自己的钩子的，除非业务项目深度使用了这个机制，来构成自己业务的插件系统。")]),s._v(" "),t("p",[s._v("另外需要注意的是，即使不声明，钩子也是可以被使用的，只要其被实现了，这里声明钩子只是为了透明。具体如何声明和实现钩子将在钩子相关小节说明。")]),s._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[s._v("WARNING")]),s._v(" "),t("p",[s._v("这里未来有可能改成不声明的钩子不让使用的逻辑")])]),s._v(" "),t("h2",{attrs:{id:"zignis-init"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zignis-init"}},[s._v("#")]),s._v(" "),t("code",[s._v("zignis init")])]),s._v(" "),t("blockquote",[t("p",[s._v("alias: "),t("code",[s._v("i")])])]),s._v(" "),t("p",[s._v("这个命令用来做初始化，可以实现两种场景，对业务项目的初始化或者对插件的初始化，这两个场景的差别在于目录结构稍有差异。")]),s._v(" "),t("p",[s._v("业务项目中，我们默认将 "),t("code",[s._v("Zignis")]),s._v(" 的目录结构放到 "),t("code",[s._v("bin")]),s._v(" 目录:")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("├── .zignisrc.json\n├── bin\n│   └── zignis\n│       ├── commands\n│       ├── extends\n│       ├── hooks\n│       ├── plugins\n│       └── scripts\n└── package.json\n\n")])])]),t("p",[s._v("而在插件项目中，我们是把所有代码放到 "),t("code",[s._v("src")]),s._v(" 目录:")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("├── .zignisrc.json\n├── src\n│    ├── commands\n│    ├── extends\n│    ├── hooks\n└── package.json\n")])])]),t("p",[s._v("这个命令存在的意义也仅仅是为了节省工程师若干秒的时间，也就是说如果不用这个命令，手动去创建这些目录和文件夹也是 OK 的。")]),s._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),t("p",[s._v("关于 "),t("code",[s._v(".zignisrc.json")]),s._v(" 的结构和用途将在配置管理小节说明")])]),s._v(" "),t("p",[s._v("另外，如果我们真的要创建一个插件，通过初始化的方式进行还是太慢了，这里推荐使用插件项目模板进行，具体的命令如下：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("zignis new zignis-plugin-xxx --select=plugin\n")])])]),t("p",[s._v("很明显这里还可以使用其他项目模板，关于 "),t("code",[s._v("new")]),s._v(" 命令，参见下放关于 "),t("code",[s._v("new")]),s._v(" 命令的介绍。")]),s._v(" "),t("h2",{attrs:{id:"zignis-make-component"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zignis-make-component"}},[s._v("#")]),s._v(" "),t("code",[s._v("zignis make <component>")])]),s._v(" "),t("blockquote",[t("p",[s._v("alias: "),t("code",[s._v("generate")]),s._v(", "),t("code",[s._v("g")])])]),s._v(" "),t("p",[s._v("这个命令是一个组件代码生成命令，这里组件的意思是对开发目标进行抽象的后的分层分类概念，比如 "),t("code",[s._v("Zignis")]),s._v(" 核心就定义了插件，命令和脚本3个概念，所以这三个概念有对应的代码生成子命令，同样的，"),t("code",[s._v("zignis")]),s._v(" 插件或者集成的项目都可以创建自己的抽象概念，并提供配套的代码生成器，比如业务项目后端会有路由，控制器，模型，数据库迁移文件，单元测试等概念，这些概念由于项目的不同可能是不通用的，但是一个项目内部最好风格保持一致，通过自动生成样板代码可以更好的保持风格一致。")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("$ zignis make help\n\nzignis make <component>\n\nGenerate component sample code\n\n命令：\n  zignis make command <name> [description]               Generate a command template\n  zignis make plugin <name>                              Generate a plugin structure\n  zignis make script <name>                              Generate a script file\n\n选项：\n  --version   显示版本号                                                                                          [布尔]\n  -h, --help  显示帮助信息                                                                                        [布尔]\n")])])]),t("h3",{attrs:{id:"扩展-make-命令添加子命令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#扩展-make-命令添加子命令"}},[s._v("#")]),s._v(" 扩展 "),t("code",[s._v("make")]),s._v(" 命令添加子命令")]),s._v(" "),t("p",[s._v("和上面扩展 "),t("code",[s._v("application")]),s._v(" 命令的方法是一样的：")]),s._v(" "),t("div",{staticClass:"language-bash extra-class"},[t("pre",{pre:!0,attrs:{class:"language-bash"}},[t("code",[s._v("zignis "),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("make")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token builtin class-name"}},[s._v("command")]),s._v(" make/test --extend"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v("zignis\n")])])]),t("p",[s._v("具体怎么实现这些代码生成命令，这里是没有做约束的，因为首先 es6 内置的模板字符串机制可以解决大多数问题，然后 "),t("code",[s._v("Zignis")]),s._v(" 还内置了 "),t("code",[s._v("lodash")]),s._v("，其 "),t("code",[s._v("_.template")]),s._v(" 方法也比较灵活，最后只要把组装好的样板代码放到想放的位置即可。")]),s._v(" "),t("p",[s._v("因为这部分都是基于 "),t("code",[s._v("Zignis")]),s._v(" 的，所以相关的配置建议放到 "),t("code",[s._v(".zignisrc.json")]),s._v(" 文件，例如自动生成的配置里就有的：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v('{\n  "commandDir": "src/commands",\n  "extendDir": "src/extends",\n  "hookDir": "src/hooks"\n}\n')])])]),t("p",[s._v("可以看到，"),t("code",[s._v("new")]),s._v(" 命令生成默认配置也仅仅是约定了一些代码自动生成的目录，同时也给出一种定义目录的配置风格，如果想保持配置的一致性，可以用同样的风格定义其他目录。")]),s._v(" "),t("h2",{attrs:{id:"zignis-new-name-repo-branch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zignis-new-name-repo-branch"}},[s._v("#")]),s._v(" "),t("code",[s._v("zignis new <name> [repo] [branch]")])]),s._v(" "),t("blockquote",[t("p",[s._v("alias: "),t("code",[s._v("n")])])]),s._v(" "),t("p",[s._v("这个命令和 "),t("code",[s._v("make")]),s._v(" 以及 "),t("code",[s._v("init")]),s._v(" 都不一样，是用来初始化一个新的项目目录的，这个项目可以是业务项目，也可以是一个插件。这个命令有很多参数，也有一些约定：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("$ zignis new help\n\nzignis new <name> [repo] [branch]\n\nCreate a new project from specific repo\n\n选项：\n  --version      显示版本号                                                                                       [布尔]\n  --yarn         use yarn command                                                                        [默认值: false]\n  --yes, -y      run npm/yarn init with --yes                                                             [默认值: true]\n  --force, -f    force download, existed folder will be deleted!\n  --merge, -m    merge config with exist project folder!\n  --empty, -e    force empty project, ignore repo\n  --select, -s   select from default repos\n  --add, -A      add npm package to package.json dependencies                                            [默认值: false]\n  --add-dev, -D  add npm package to package.json devDependencies                                         [默认值: false]\n  --init, -i     init new project\n  -h, --help     显示帮助信息                                                                                     [布尔]\n")])])]),t("p",[s._v("单个的说明上面已经有了，下面我们用具体的使用场景说明一下")]),s._v(" "),t("h3",{attrs:{id:"从任意代码仓库初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#从任意代码仓库初始化"}},[s._v("#")]),s._v(" 从任意代码仓库初始化")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("zignis new PROJECT_NAME PROJECT_REPO_URL master -f\n")])])]),t("p",[s._v("这里可以看出，我们用 new 命令可以从任意 git 仓库地址下载代码，任何代码仓库都可以是我们的项目模板。其中 "),t("code",[s._v("master")]),s._v(" 是分支名，默认就是 "),t("code",[s._v("master")]),s._v(" 所以可以省略，"),t("code",[s._v("-f")]),s._v(" 的意思是如果目录已经存在，会先删除原来的，再重新创建。")]),s._v(" "),t("p",[s._v("new 命令除了把代码下载下来，还帮着把原来的 "),t("code",[s._v(".git")]),s._v(" 目录删除了，并且重新初始化了一个空的 "),t("code",[s._v(".git")]),s._v(" 目录，然后把项目的依赖都自动下载下来了。")]),s._v(" "),t("h3",{attrs:{id:"创建一个空项目，不基于任何项目模板"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建一个空项目，不基于任何项目模板"}},[s._v("#")]),s._v(" 创建一个空项目，不基于任何项目模板")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("zignis new PROJECT_NAME -yfie\n")])])]),t("p",[s._v("这里可以看到一个 "),t("code",[s._v("yargs")]),s._v(" 的特性，可以把短参数连起来用，这里相当于 "),t("code",[s._v("-y -f -i -e")]),s._v("，也就是，"),t("code",[s._v("-y")]),s._v(" 帮我们在创建了 "),t("code",[s._v("package.json")]),s._v("时自动回答 "),t("code",[s._v("yes")]),s._v("，"),t("code",[s._v("-f")]),s._v(" 是强制删除已存在的目录，"),t("code",[s._v("-i")]),s._v(" 是自动执行 "),t("code",[s._v("zignis init")]),s._v(" 初始化项目目录， "),t("code",[s._v("-e")]),s._v(" 是告诉命令，即不基于代码仓库，也不基于内置模板，而是要声明一个空项目。")]),s._v(" "),t("p",[s._v("项目的目录结构如下：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("├── .zignisrc.json\n├── bin\n│   └── zignis\n│       ├── commands\n│       ├── extends\n│       ├── hooks\n│       ├── plugins\n│       └── scripts\n└── package.json\n")])])]),t("h3",{attrs:{id:"创建一个-zignis-插件目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#创建一个-zignis-插件目录"}},[s._v("#")]),s._v(" 创建一个 "),t("code",[s._v("Zignis")]),s._v(" 插件目录")]),s._v(" "),t("p",[s._v("如果不基于插件模板，我们可以手动创建一个基本的插件结构：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("zignis new zignis-plugin-[PLUGIN_NAME] -yfie\n")])])]),t("p",[s._v("可以看到，和上面很类似，除了项目名，这里存在一个项目名称的约定，如果项目名称以 "),t("code",[s._v("zignis-plugin-")]),s._v(" 开头，则认为是在初始化一个 "),t("code",[s._v("Zignis")]),s._v(" 插件，初始化时会执行 "),t("code",[s._v("zignis init --plugin")]),s._v("。")]),s._v(" "),t("p",[s._v("项目的目录结构如下：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("├── .zignisrc.json\n├── package.json\n└── src\n    ├── commands\n    ├── extends\n    └── hooks\n")])])]),t("h3",{attrs:{id:"基于内置模板创建项目"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基于内置模板创建项目"}},[s._v("#")]),s._v(" 基于内置模板创建项目")]),s._v(" "),t("p",[s._v("如果我们创建项目执行下面的命令:")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("zignis new PROJECT_NAME --select\n")])])]),t("p",[s._v("则会看到下面的输出:")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("? Please choose a pre-defined repo to continue: (Use arrow keys)\n❯ zignis_plugin_starter [zignis-plugin-starter, plugin]\n❯ ...\n")])])]),t("p",[s._v("这里可以选择一个想要选择的内置模板，也就是不用主动输入仓库地址了，这里默认只有一个插件模板，但是可以使用 "),t("code",[s._v("hook_new_repo")]),s._v(" 注入其他模板地址进去：")]),s._v(" "),t("p",[s._v("钩子实现示例，更多关于钩子的用法，请参见钩子相关说明")]),s._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("export")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" hook_new_repo "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  demo_repo"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    repo"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'demo_repo.git'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n    branch"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'master'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n    alias"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("[")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'demo'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("]")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),t("p",[s._v("如果在初始化的时候已经知道要使用的模板和标识，可以直接指定：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("zignis new PROJECT_NAME --select=demo\nzignis new PROJECT_NAME --select=demo_repo\n")])])]),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),t("p",[s._v("在创建业务项目或者插件时，不推荐从空项目开始，因为还要考虑很多工程化的问题，技术选型的问题，推荐归纳总结自己公司常用的脚手架项目，然后通过统一的方式进行初始化。比如内置的插件模板，初始化后，可以直接编写逻辑，然后代码上传到 "),t("code",[s._v("Github")]),s._v(" 再执行 "),t("code",[s._v("npm version patch && npm publish")]),s._v(" 即可发布到 npm 仓库了。关于如何开发一个插件并且发布到 "),t("code",[s._v("npm")]),s._v(" 仓库，会单独写文档说明。")])]),s._v(" "),t("p",[s._v("剩余的其他几个选项也很好理解，"),t("code",[s._v("--yarn")]),s._v(" 声明项目使用 "),t("code",[s._v("yarn")]),s._v(" 来初始化和安装依赖，"),t("code",[s._v("--add")]),s._v(" 和 "),t("code",[s._v("--add-dev")]),s._v(" 用来在初始化时指定新的依赖包。"),t("code",[s._v("--merge")]),s._v(" 是说不删除原来的项目，而是进入项目目录，然后应用 "),t("code",[s._v("--init")]),s._v(", "),t("code",[s._v("--add")]),s._v(", "),t("code",[s._v("--add-dev")]),s._v("。")]),s._v(" "),t("h2",{attrs:{id:"zignis-repl"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zignis-repl"}},[s._v("#")]),s._v(" "),t("code",[s._v("zignis repl")])]),s._v(" "),t("blockquote",[t("p",[s._v("alias: "),t("code",[s._v("r")])])]),s._v(" "),t("p",[s._v("REPL(read-eval-print-loop)：交互式解析器，每一个现代的编程语言大概都有这类交互环境，在里面我们可以写一些简单的代码，做为一个快速了解和学习语言特性的工具。但是当 REPL 可以和框架或者业务项目结合以后，可以发挥出更大的作用。")]),s._v(" "),t("h3",{attrs:{id:"对-repl-的一些扩展"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对-repl-的一些扩展"}},[s._v("#")]),s._v(" 对 "),t("code",[s._v("REPL")]),s._v(" 的一些扩展")]),s._v(" "),t("p",[s._v("默认 REPL 的退出只能通过 "),t("code",[s._v("ctrl+c")]),s._v(" 或者 "),t("code",[s._v("ctrl+d")]),s._v(" 或者 "),t("code",[s._v(".exit")]),s._v(" 来进行，这里我们加入了几个快捷的命令，"),t("code",[s._v("quit")]),s._v(", "),t("code",[s._v("q")]),s._v(", "),t("code",[s._v("exit")]),s._v("。")]),s._v(" "),t("p",[s._v("在开发Zignis 和这个脚手架时，Node 的 REPL 还不支持 "),t("code",[s._v("await")]),s._v("，这里是模拟实现了这个机制，目的是可以触发执行项目中的一些 promise 或 generator 方法。通过这个能力，再加上我们可以把一些业务代码注入到 "),t("code",[s._v("REPL")]),s._v(" 我们就可以在接口控制器，脚本，单元测试之外多了一种执行方式，而这种执行方式还是交互式的。")]),s._v(" "),t("h3",{attrs:{id:"为-repl-注入新的对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为-repl-注入新的对象"}},[s._v("#")]),s._v(" 为 "),t("code",[s._v("REPL")]),s._v(" 注入新的对象")]),s._v(" "),t("p",[s._v("这里需要实现内置的 "),t("code",[s._v("hook_repl")]),s._v(" 钩子，并且在业务项目的声明的钩子目录配置： "),t("code",[s._v("hookDir")]),s._v("，下面代码仅供参考。")]),s._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[s._v("# src"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("hooks"),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("/")]),s._v("index"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),s._v("ts\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("export")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[s._v("hook_repl")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=>")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[s._v("add")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("async")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" b")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=>")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n      "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" a "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("+")]),s._v(" b\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("\n    "),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[s._v("multiple")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("async")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("a"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" b")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=>")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n      "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" a "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("*")]),s._v(" b\n    "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n")])])]),t("p",[s._v("然后在 REPL 环境，就可以使用了:")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v(">>> add\n[Function: add]\n>>> await add(1, 2)\n3\n>>> multiple\n[Function: multiple]\n>>> await multiple(3, 4)\n12\n")])])]),t("p",[s._v("在实际的业务项目中，会把项目中的公共方法，工具函数等等都注入进去，这对开发以及后面的排查问题都是很有帮助的。默认 "),t("code",[s._v("Zignis")]),s._v(" 把自己的 "),t("code",[s._v("Utils")]),s._v(" 工具对象注入进去了，里面有一些是 "),t("code",[s._v("Zignis")]),s._v(" 自定义的工具函数，更多的是把 "),t("code",[s._v("Zignis")]),s._v(" 引入的依赖包暴露出来，比如 "),t("code",[s._v("lodash")]),s._v("。")]),s._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[s._v("TIP")]),s._v(" "),t("p",[s._v("在具体的实践中，我们把数据库，缓存，OSS，Consul, ElasticSearch 等等多种公司的基础设施注入了进来，写成插件，使得我们更容易的直接访问基础设施。")])]),s._v(" "),t("h2",{attrs:{id:"zignis-script-file"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zignis-script-file"}},[s._v("#")]),s._v(" "),t("code",[s._v("zignis script [file]")])]),s._v(" "),t("blockquote",[t("p",[s._v("alias: "),t("code",[s._v("scr")])])]),s._v(" "),t("p",[s._v("很多时候我们都需要跑一些脚本，这些脚本是在项目服务之外的，需要我们主动触发，可能是做数据迁移，可能是数据导出，可能是数据批量修改，也可能是执行业务逻辑，比如发邮件，发短信，发通知等等。在遇到这样的需求的时候，我们都需要写脚本，但是我们会遇到几个问题：")]),s._v(" "),t("ul",[t("li",[s._v("放哪里")]),s._v(" "),t("li",[s._v("怎么写")]),s._v(" "),t("li",[s._v("脚本参数怎么解析")])]),s._v(" "),t("p",[s._v("很多时候这些需求都是一次性的，或者有前提的，不是很适合写成命令，不然命令就太多了，在这种场景下，"),t("code",[s._v("Zignis")]),s._v(" 通过这条命令给出了一个统一的方案。")]),s._v(" "),t("h3",{attrs:{id:"放哪里"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#放哪里"}},[s._v("#")]),s._v(" 放哪里")]),s._v(" "),t("p",[s._v("在配置中有一个 "),t("code",[s._v("scriptDir")]),s._v("，默认是 "),t("code",[s._v("src/scripts")]),s._v("，我们默认把脚本都放到这里，因为这些脚本不会被服务访问到，所以没必要和项目核心逻辑放的太近。")]),s._v(" "),t("h3",{attrs:{id:"怎么写，怎么解析参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#怎么写，怎么解析参数"}},[s._v("#")]),s._v(" 怎么写，怎么解析参数")]),s._v(" "),t("p",[s._v("当然可以手动建脚本，然后用这个命令来触发，但是因脚本还需要起名字，而且还有一定的格式要求，所以，推荐使用 "),t("code",[s._v("zignis make script")]),s._v(" 命令来生成。")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("zignis make script test\n")])])]),t("p",[s._v("自动生成的样板代码及文件名：")]),s._v(" "),t("div",{staticClass:"language-js extra-class"},[t("pre",{pre:!0,attrs:{class:"language-js"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// src/bin/zignis/scripts/20191025130716346_test.ts")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("export")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[s._v("builder")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("yargs"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" any")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  "),t("span",{pre:!0,attrs:{class:"token comment"}},[s._v("// yargs.option('option', {default, describe, alias})")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("export")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("const")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token function-variable function"}},[s._v("handler")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("async")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token parameter"}},[s._v("argv"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(":")]),s._v(" any")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n  console"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token string"}},[s._v("'Start to draw your dream code!'")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n  process"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[s._v("exit")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])])]),t("p",[s._v("可以看到，作为一个脚本，不是一上来就写业务逻辑，也不需要声明 "),t("code",[s._v("shebang")]),s._v(" 标识，只需要定义两个方法，一个是 "),t("code",[s._v("builder")]),s._v("，一个是 "),t("code",[s._v("handler")]),s._v("。其中 "),t("code",[s._v("builder")]),s._v(" 用于声明脚本的参数，格式可以参考 "),t("code",[s._v("yargs")]),s._v("，如果脚本不需要参数，其实也可以不定义，由于是模板自动生成，放到那里即可，以备不时之需。"),t("code",[s._v("handler")]),s._v(" 是具体的执行逻辑，传入的参数就是解析好的脚本参数，也包含了项目的 "),t("code",[s._v(".zignisrc.json")]),s._v(" 里的配置。可以看到 "),t("code",[s._v("handler")]),s._v(" 支持 "),t("code",[s._v("async")]),s._v(" 所以这里可以执行一些异步操作。")]),s._v(" "),t("p",[s._v("所以，脚本和命令最大的区别其实就是使用的频率，以及业务的定位，我们经常做的分层是定义原子命令，然后在脚本中调度。")]),s._v(" "),t("h2",{attrs:{id:"zignis-shell"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zignis-shell"}},[s._v("#")]),s._v(" "),t("code",[s._v("zignis shell")])]),s._v(" "),t("blockquote",[t("p",[s._v("alias: "),t("code",[s._v("sh")])])]),s._v(" "),t("p",[s._v("这个命令是个很简单的命令，目的是不用每次敲命令都输入前面的 "),t("code",[s._v("zignis")]),s._v("，例如：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("zignis shell\n> status\n> hook\n> repl\n")])])]),t("p",[s._v("这个命令平时的使用频率不是很高，但是也许有一些人会喜欢使用。退出和 "),t("code",[s._v("repl")]),s._v(" 命令一样支持："),t("code",[s._v("q")]),s._v(", "),t("code",[s._v("quit")]),s._v(", "),t("code",[s._v("exit")]),s._v("。这里还有个额外的用法是，你也可以修改前缀，对其他多层级的命令行工具实现类似的效果，比如:")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("zignis shell --prefix=git\n> log\n> remote -v\n")])])]),t("h2",{attrs:{id:"zignis-status"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zignis-status"}},[s._v("#")]),s._v(" "),t("code",[s._v("zignis status")])]),s._v(" "),t("blockquote",[t("p",[s._v("alias: "),t("code",[s._v("st")])])]),s._v(" "),t("p",[s._v("这个命令的作用很简单，就是看 "),t("code",[s._v("Zignis")]),s._v(" 当前所处的环境，例如：")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("$ zignis st\nCore Information\n  version  :  1.8.17\n  location :  ~/.nvm/versions/node/[VERSION]/lib/node_modules/zignis\n  os       :  macOS 10.15\n  node     :  8.16.2\n  npm      :  6.4.1\n  yarn     :  1.15.2\n  hostname :  [MY_HOST]\n  home     :  [MY_HOME]\n  shell    :  [MY_SHELL]\n")])])]),t("p",[s._v("如果加上 "),t("code",[s._v("--plugin")]),s._v(" 参数，还可以看安装的插件信息，主要是插件目录和版本，插件也可以使用 "),t("code",[s._v("hook_status")]),s._v(" 钩子添加更多的状态信息。注意插件扫描是动态的，不同的目录扫描的插件列表是不一样的，具体参看插件相关文档。")]),s._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[s._v("[zignis-plugin-x]\n  version  :  0.0.13\n  location :  ~/.nvm/versions/node/[VERSION]/lib/node_modules/zignis-plugin-x\n\n[zignis-plugin-y]\n  version  :  1.8.39\n  location :  ~/.nvm/versions/node/[VERSION]/lib/node_modules/zignis-plugin-y\n\n[zignis-plugin-z]\n  version  :  0.0.2\n  location :  ~/.nvm/versions/node/[VERSION]/lib/node_modules/zignis-plugin-z\n")])])]),t("h2",{attrs:{id:"zignis-completion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zignis-completion"}},[s._v("#")]),s._v(" "),t("code",[s._v("zignis completion")])]),s._v(" "),t("p",[s._v("这个命令的作用是输出一段 "),t("code",[s._v("Shell")]),s._v(" 脚本，放到 "),t("code",[s._v(".bashrc")]),s._v(" 或者 "),t("code",[s._v(".zshrc")]),s._v(" 里，就能够获得子命令的自动补全效果。")]),s._v(" "),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[s._v("WARNING")]),s._v(" "),t("p",[s._v("由于 "),t("code",[s._v("Zignis")]),s._v(" 的性能有些查，所以这个自动补全虽然能用，但是体验极差，不建议使用。")])])])}),[],!1,null,null,null);a.default=n.exports}}]);